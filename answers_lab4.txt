Isabella ValdescruzEECS 339 Lab 4 Writeup 	In this lab, I think my biggest struggle was figuring out what synchronization meant. I got so stuck on the blocking implementation for the first few days of working on it because I did not fully understand what the method was doing or where I should be using it. I basically tried to make my own version of synchronization in a separate java class to do exactly what the method did for me. After I got out of that roadblock, by deleting my Heap Page/Heap File/Buffer Pool and using your implementation of it, the rest of the lab did not take me very long to finish; I would estimate probably 10-15 hours. 	In order to implement page-level locking I only acquired my locks in the getPage function of BufferPool. To do this I made a separate .java class called LockManager that would handle all of the locks separately from the functions in BufferPool. In my LockManager class, I used two hashmaps, one that mapped PageIds to a Set of TransactionIds that would keep track of the shared locks on a page and another that mapped a PageId to a TransactionId that would keep track of an exclusive lock that the Page held. The shared hashmap needs to be able to map a PageId to multiple TransactionIds since multiple transactions can hold a shared lock on  a page, but the hashmap for exclusive pages only needs to map a pageId to one TransactionId because a page can only hold one exclusive lock at a time. One thing I did get caught up on for awhile was I tried to implement the shared hash map to have a pageId map to a List of TransactionIds. I eventually realized that this didn’t work because it would allow duplicate copies of a transaction to show up in a pageId’s list and when I would try to remove it in the release page function, it would only remove one instance of the duplicate, thus not actually removing the lock on the page.	Within the LockManager class, I implemented functions to set a shared lock, set an exclusive lock, and release locks on pages when transactions were committed or aborted. In order to commit a transaction, I just flushed the pages associated to that TransactionId to the disk and then released all the locks associated with that page. When I needed to abort due to a deadlock, I used the two functions from the Page class, getImageBefore and setBeforeImage, to restore the dirtypage that was associated with the current transactionID to its on disk state thus implementing only an abort on that transaction and not the other ones. To handle deadlocks, I implemented a version of a timeout, but instead of using the java commands System.currentTimeMillis I used a counter that incremented each time a blocked transaction tried to aquire a lock again. If the counter got to be above 10 times, I would assume deadlock and throw the TransactionAbortedException.  
	The only test that I did not pass was the BTreeNextKeyLockingTest. I keep getting an assertion error for it that says "Expected 25602 but got 25603". After looking through the test code I saw that meant I was getting a phantom somewhere in my code because the counts were off. I spent awhile trying to debug this issue, and I have the feeling that it is something in my findLeafPage function but I am not completely sure since I have no problems with any of the other tests.	I would like to thank you for teaching this incredibly challenging, yet very rewarding class. It has definitely been one of the hardest classes I have taken at Northwestern, but I think my programming skills have improved immensely because of it. I have brought it up in every interview I have had and everyone seems very impressed. So thank you!
Isabella ValdescruzEECS 339 Lab 2 Write Up		In this lab I didnâ€™t find anything particularly difficult; it was much easier and less overwhelming than the first one, as I am picking up more and more knowledge about Java and what the project is expecting us to do. What I struggled the most with was passing the test in the BufferPoolWriteTest:: HandleManyDirtyPages. It took me hours after passing every other test to figure out that my bug was an issue in my HeapFileIterator, something I implemented in the last lab and did not think I would need to update in this one. Other than that though, the concepts were familiar enough from lecture that I felt like I could figure out what it was asking for. I probably spent around 30 hours on it, which was half the time I spent on the first lab so it is definitely getting easier as I understand more. 
	I did not make any changes to the API and used most of the functions that were given to us. I tried to implement something besides a nested-loops join in the Join class, but was unable to get anything to work so I stuck with the nested join. I did, however decide to implement a Least Frequently Used Policy for my Eviction Policy. The way I did this was by creating an array of PageIds that is the size of the maximum number of pages that the buffer pool can hold. Each time a page would get added to the buffer pool, it would be placed at the next empty spot in the array and a counter for the current slot would be incremented. Once the buffer pool was at its capacity, the array of PageIds would also be representative of that. In order to choose which page to evict, simpleDb selects the PageId at the very beginning of the array, at index 0, which was the first page added to the array and the one that we had touched the least frequently. After we select that page we shift all of the PageIds over to the left by one in order to make up for that and we insert the PageId that we are currently attempting to add in the last index of the array. Basically the first indexes of the array correspond to the Pages that we have looked up the least frequent amount of times and the last indexes of the array correspond to pages that we are frequently retrieving. 
	In order to delete and insert Tuples from the HeapPage I manipulated the MarkSlotUsed function within HeapPage and used a lot of bit logic. If I wanted to insert a tuple, I retrieved the first empty slot in the header array by going through each slot in a for loop and checking to see if the slot was used or not. If it was used then I returned that specific index. After finding the index, I would insert the tuple into the tuples array at that index and then call the MarkSlotUsed function to change the bits of the header byte. I would find the specific byte that the slot I wanted to update was in, and then create a mask with a one shifted over to the specific bit that I wanted to change. By doing a logical OR with that mask and the header byte I was able to change none of the other bits in that byte except for the one that was being ORed with the one (the slot that I wanted to change to a one). To delete a tuple, I basically did the reverse and performed a logical AND test with the header byte and a mask of all ones and a zero shifted to the correct bit in the header byte, thus producing an identical byte, with just the current slot being updated to a zero indicating that it was empty.